for(i in 1:length(p)) {
S[i] = -3/log(1-p)
}
plot(p~S)
p = c(0.05, 0.01, 0.001, 0.0001, 0.00001)
for(i in 1:length(p)) {
S[i] = -3/log(1-p)
}
source('~/.active-rstudio-document', echo=TRUE)
p = c(0.05, 0.01, 0.001, 0.0001, 0.00001)
s = (0, length(p))
s = rep(0, length(p))
for(i in 1:length(p)) {
S[i] = -3/(log(1-p))
}
p = c(0.05, 0.01, 0.001, 0.0001, 0.00001)
s = rep(0, length(p))
for(i in 1:length(p)) {
S[i] = -3/(log(1-p[i]))
}
plot(p~S)
freq<-seq(0.05,0.001,by=-.001)
S<-rep(0,length(freq))
for (p in 1:length(freq)) {
S[p]<-3/(log(1-freq[p]))
}
plot(S~freq)
p = c(0.05, 0.01, 0.001, 0.0001, 0.00001) #defining frequencies
s = rep(0, length(p))#declaring S
#for loop, iterates through the length of p
for(i in 1:length(p)) {
S[i] = -3/(log(1-p[i]))
}
plot(p~S)
plot(S~p)
source('~/.active-rstudio-document', echo=TRUE)
p = c(0.05, 0.025, 0.0125, 0.00625, 0.00313, 0.00156, 0.000781, 0.000391, 0.000195) #defining frequencies
s = rep(0, length(p))#declaring S
p = c(0.05, 0.025, 0.0125, 0.00625, 0.00313, 0.00156, 0.000781, 0.000391, 0.000195) #defining frequencies
s = rep(0, length(p)) #declaring S to be the same length as p with values of 0
#for loop, iterates through the length of p
for(i in 1:length(p)) {
S[i] = -3/(log(1-p[i])) #re-declaring S with the values calcualted by the equation
}
plot(S~p)
S
p
p = <-seq(0.05,0.001,by=-.001) #defining frequencies
s = rep(0, length(p)) #declaring S to be the same length as p with values of 0
p <-seq(0.05,0.001,by=-.001) #defining frequencies
s = rep(0, length(p)) #declaring S to be the same length as p with values of 0
#for loop, iterates through the length of p
for(i in 1:length(p)) {
S[i] = -3/(log(1-p[i])) #re-declaring S with the values calcualted by the equation
}
plot(S~p)
S[i] = 3/(log(1-p[i])) #re-declaring S with the values calcualted by the equation
#for loop, iterates through the length of p
for(i in 1:length(p)) {
S[i] = 3/(log(1-p[i])) #re-declaring S with the values calcualted by the equation
}
plot(S~p)
p <-seq(0.05,0.001,by=-.001) #defining frequencies by creating a sequence of numbers from 0.05 to 0.001 by -0.001
s = rep(0, length(p)) #declaring S to be the same length as p, filled with values of 0
#for loop, iterates through the length of p calculating S for each value of p
for(i in 1:length(p)) {
S[i] = 3/(log(1-p[i])) #re-declaring S with the values calcualted by the equation
}
plot(S~p)
p <-seq(0.05,0.001,by=-.001) #defining frequencies by creating a sequence of numbers from 0.05 to 0.001 by -0.001
s = rep(0, length(p)) #declaring S to be the same length as p, filled with values of 0
#for loop, iterates through the length of p calculating S for each value of p
for(i in 1:length(p)) {
S[i] = 3/(log(1-p[i])) #re-declaring S with the values calcualted by the equation
}
plot(S~p)
p <-seq(0.05,0.001,by=-.001)
s = rep(0, length(p))
r = c(1, 2, 3, 4, 5, 6, 8, 10, 15)
for(i in 1:length(p)) {
S[i] = (r + (1.645*sqrt(r)) + 0.5)/p
}
plot(S~p)
plot(S, p, r)
plot(S)
plot(S~p)
plot(S~r)
plot(S~p)
r = c(1, 2, 3, 4, 5, 6, 8, 10, 15)
p = c(0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.05)
s = rep(0, length(p))
r = c(1, 2, 3, 4, 5, 6, 8, 10, 15)
for(i in 1:length(p)) {
S[i] = (r + (1.645*sqrt(r)) + 0.5)/p
}
warnings()
source('~/Research/Morton REU/equation2_brown.R', echo=TRUE)
p = c(0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.05)
s = c(0, 0, 0, 0, 0, 0)
r = c(1, 2, 4, 8, 10, 15)
for(i in 1:length(p)) {
S[i] = (r + (1.645*sqrt(r)) + 0.5)/p
}
p
s
source('~/Research/Morton REU/equation3_brown.R', echo=TRUE)
r
S[i] = (r[i] + (1.645*sqrt(r[i])) + 0.5)/p[i]
p = c(0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.05)
s = c(0, 0, 0, 0, 0, 0)
r = c(1, 2, 4, 8, 10, 15)
for(i in 1:length(p)) {
S[i] = (r[i] + (1.645*sqrt(r[i])) + 0.5)/p[i]
}
plot(S~p)
s
p = c(0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.05)
s = c(0, 0, 0, 0, 0, 0)
r = c(1, 2, 4, 8, 10, 15)
for(i in 1:length(p)) {
S[i] = (r[i] + (1.645*sqrt(r[i])) + 0.5)/p[i]
}
s
table1 = table(c(p, r, S))
table1
data = data.frame(p, r. S)
data = data.frame(p, r, S)
for(i in 1:6){
print(s[i])
}
1
p = c(0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.05)
S = c(0, 0, 0, 0, 0, 0)
r = c(1, 2, 4, 8, 10, 15)
for(i in 1:length(p)) {
S[i] = (r[i] + (1.645*sqrt(r[i])) + 0.5)/(p[i])
}
for(i in 1:6){
print(S[i])
}
#make a table to display values
to.data.frame(p, r, S)
#make a table to display values
data.frame(p, r, S)
#defining variables with similar values to the table in Brown paper
p = c(0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.05)
S = c(0, 0, 0, 0, 0, 0)
r = c(1, 2, 4, 8, 10, 15)
#using equation 3 to calculate S
for(i in 1:length(p)) {
for(i in 1:length(r)) {
S[i] = (r[i] + (1.645*sqrt(r[i])) + 0.5)/(p[i])
}
}
#printing values of S
for(i in 1:6){
print(S[i])
}
#make a table to display values
data.frame(p, r, S)
#using equation 3 to calculate S
for(i in 1:length(p)) {
for(j in 1:length(r)) {
S[i] = (r[i] + (1.645*sqrt(r[i])) + 0.5)/(p[i])
}
}
#printing values of S
for(i in 1:6){
print(S[i])
}
#make a table to display values
data.frame(p, r, S)
#using equation 3 to calculate S
for(i in 1:length(p)) {
for(j in 1:length(r)) {
S[i] = (r[i,j] + (1.645*sqrt(r[i,j])) + 0.5)/(p[i,j])
}
}
#using equation 3 to calculate S
for(i in 1:length(p)) {
for(j in 1:length(r)) {
S[i,j] = (r[i] + (1.645*sqrt(r[i])) + 0.5)/(p[i])
}
}
#defining variables with similar values to the table in Brown paper
p = c(0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.05)
#S = c(0, 0, 0, 0, 0, 0)
S = matrix(1:36, byrow = TRUE, nrow = 6)
r = c(1, 2, 4, 8, 10, 15)
S
#using equation 3 to calculate S
for(i in 1:length(p)) {
for(j in 1:length(r)) {
S[i,j] = (r[i] + (1.645*sqrt(r[i])) + 0.5)/(p[i])
}
}
print(S[i,j])
#printing values of S
for(i in 1:6){
for(j in 1:6) {
print(S[i,j])
}
}
#make a table to display values
data.frame(p, r, S)
#defining variables with similar values to the table in Brown paper
p = c(0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.05)
#S = c(0, 0, 0, 0, 0, 0)
S = matrix(1:36, byrow = TRUE, nrow = 6)
r = c(1, 2, 4, 8, 10, 15)
#using equation 3 to calculate S
for(i in 1:length(p)) {
for(j in 1:length(r)) {
S[i,j] = (r[i] + (1.645*sqrt(r[i])) + 0.5)/(p[i])
}
}
#printing values of S
for(i in 1:6){
for(j in 1:6) {
print(S[i,j])
}
}
#make a table to display values
data.frame(p, r, S)
#using equation 3 to calculate S
for(i in 1:length(p)) {
for(j in 1:length(r)) {
S[i,j] = (r[j] + (1.645*sqrt(r[j])) + 0.5)/(p[j])
}
}
#printing values of S
for(i in 1:6){
for(j in 1:6) {
print(S[i,j])
}
}
#using equation 3 to calculate S
for(i in 1:length(p)) {
S[i,j] = (r[i] + (1.645*sqrt(r[i])) + 0.5)/(p[i])
for(j in 1:length(r)) {
S[i,j] = (r[j] + (1.645*sqrt(r[j])) + 0.5)/(p[j])
}
}
#printing values of S
for(i in 1:6){
for(j in 1:6) {
print(S[i,j])
}
}
#make a table to display values
data.frame(p, r, S)
#using equation 3 to calculate S
for(i in 1:length(p)) {
for(j in 1:length(r)) {
S[i,j] = (r[j] + (1.645*sqrt(r[j])) + 0.5)/(p[i])
}
}
#defining variables with similar values to the table in Brown paper
p = c(0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.05)
#S = c(0, 0, 0, 0, 0, 0)
S = matrix(1:36, byrow = TRUE, nrow = 6)
r = c(1, 2, 4, 8, 10, 15)
#using equation 3 to calculate S
for(i in 1:length(p)) {
for(j in 1:length(r)) {
S[i,j] = (r[j] + (1.645*sqrt(r[j])) + 0.5)/(p[i])
}
}
#make a table to display values
data.frame(p, r, S)
S <- as.data.frame(S)
rownames(S) <- r
colnames(S) <- p
#change S to a data frame
S <- as.data.frame(S)
S
round(S)
q()
library(diveRsity)
library(adegenet)
#import functions
import_arp2gen_files = function(mypath, mypattern) {
temp_list_1 = list.files(mypath, mypattern)
temp_list_2 = list(length = length(temp_list_1))
for(i in 1:length(temp_list_1)){temp_list_2[[i]]=arp2gen(temp_list_1[i])}
temp_list_2
}
import_gen2genind_objects = function(mypath, mypattern) {
temp_list_3 = list.files(mypath, mypattern)
temp_list_4 = list(length = length(temp_list_3))
for(j in 1:length(temp_list_3)){temp_list_4[[j]]=read.genepop(temp_list_3[j], ncode=3)}
temp_list_4
}
dir("C:\\Users\\kayle\\Documents\\Morton-REU\\practice\\Simulations\\simcoal2\\compare_migration")
files = list.files("C:\\Users\\kayle\\Documents\\Morton-REU\\practice\\Simulations\\simcoal2\\compare_migration", recursive = T, pattern = ".arp$")
files
files[[1]]
for(i in 1:length(files)) {
gen_files = list(arp2gen(files[[i]]))
}
files
hello_function()
hello_function = function() {
print("Hello world!")
}
hello_function()
myData = PlantGrowth
View(myData)
anova_results = aov(weight ~ group, data = myData)
summary.aov(anova_results)
myData = PlantGrowth
View(myData)
anova_results = aov(weight ~ group, data = myData)
summary.aov(anova_results)
View(myData)
anova_results = aov(weight ~ group, data = myData)
summary.aov(anova_results)
int x = 2;
X
#Library functions
library(adegenet)
library(car)
library(diveRsity)
library(ggplot2)
library(ggpubr)
library(ggsignif)
library(tidyr)
library(hierfstat)
#FLAGS
#file conversion flag
#set to true once files have been converted once
#false if you want to convert files
conversion_flag = TRUE
#Fst flag
#Fst code adds a lot of time to run the code
#so if you don't want to run it, keep Fst off by setting it FALSE
fst_flag = FALSE
#Set working directory
mydir = "C:\\Users\\kayle\\Documents\\Quercus_IUCN_samp_sims\\Simulations"
setwd(mydir)
#creating a list of the species we have simulated
species_list = c("\\q_acerifolia",
"\\q_arkansana",
"\\q_boyntonii",
"\\q_carmenensis",
"\\q_cedrosensis",
"\\q_engelmannii",
"\\q_georgiana",
"\\q_graciliformis",
"\\q_havardii",
"\\q_hinckleyii",
"\\q_oglethorpensis",
"\\q_pacifica")
#defining the maximum number of individuals we want to sample
#for practical purposes, this will be 500 indivduals
max_sample_size = 500
#number of replicates of genetic simulation
num_replicates = 1000
#pre-defining the array to store results
#first dimension: 500, sampling from 1 to 500 individuals per species, saving results for each iteration
#second dimension: 100 for 100 simulation replicates per species
#third dimension: 12, for 12 quercus species. this is represented by the outer for loop (12 matrix 'slices')
all_quercus_results = array(0, dim = c(500,1000,12))
total_alleles_all_quercus = array(0, dim=c(500,1000,12))
#storing Fst results
#saving a list of genind objects created
temp_genind_list <- list()
#list of hierfstat
temp_hierfstat <- list()
##min, max, mean of replicates
mean_max_min_fst = array(dim = c(3,1000,12))
##min, max, mean of replicates
mean_max_min_fst = array(dim = c(3,100,12))
#Fst flag
#Fst code adds a lot of time to run the code
#so if you don't want to run it, keep Fst off by setting it FALSE
fst_flag = TRUE
#Loop to simulate sampling
#First, create a list of all genepop files (all replicates) to loop over
#the variable 'i' represents each replicate
for(i in 1:length(species_list)) {
setwd(paste(mydir,species_list[i],sep=""))
list_files = list.files(paste(mydir,species_list[i],sep=""), pattern = ".gen$")
for(j in 1:100)) { #(length(list_files))
#creating a temporary genind object (using Adegenet package) for each simulation replicate
temp_genind = read.genepop(list_files[[j]], ncode=3)
#calculating Fst
if(fst_flag == TRUE) {
##creating genind list for QUAC genind
temp_genind_list[[j]] <- temp_genind
##convert genind files to hierfstat format to run pwfst
temp_hierfstat[[j]] <- genind2hierfstat(temp_genind_list[[j]])
##array to store all pwfst values
pwfst <- pairwise.neifst(temp_hierfstat[[j]])
##calculate statistics for QUAC - max, min, mean fst
##and save results in a matrix for all species
mean_max_min_fst[1,j,i] <- mean(pwfst, na.rm = TRUE)
mean_max_min_fst[2,j,i] <- min(pwfst, na.rm = TRUE)
mean_max_min_fst[3,j,i] <- max(pwfst, na.rm = TRUE)
}
#defining the first and last individuals of the entire population, so we know where to sample between
first_ind = 1
last_ind = sum(table(temp_genind@pop))
#for each replicate, sample up to 500 individuals, starting with 1
for(k in 1:max_sample_size) {
#this is a check to make sure that k, the sample size, doesn't exceed the species total pop. size
#the loop will break if k is greater than the total pop. size
#in other words, sampling stops once the entire population has been sampled, or when 500 samples is reached
if(k <= sum(table(temp_genind@pop))) {
#choosing which rows of the matrix to sample from
#rows indicate individuals
rows_to_samp = sample(first_ind:last_ind, k)
#saving the alleles sampled
if(k == 1) {
sample_n_alleles = sum(temp_genind@tab[rows_to_samp,]>0)
} else {
sample_n_alleles = sum(colSums(temp_genind@tab[rows_to_samp,])>0)
}
#calculating the total alleles
total_alleles = ncol(temp_genind@tab)
#saving the proportion of alleles captured -> alleles sampled/total alleles
#represents genetic conservation success
all_quercus_results[k,j,i] = sample_n_alleles/total_alleles
#saving the total alleles present across the populations for each species, and each replicate
total_alleles_all_quercus[k,j,i] = total_alleles
}else {
break
}
}
}
}
#Loop to simulate sampling
#First, create a list of all genepop files (all replicates) to loop over
#the variable 'i' represents each replicate
for(i in 1:length(species_list)) {
setwd(paste(mydir,species_list[i],sep=""))
list_files = list.files(paste(mydir,species_list[i],sep=""), pattern = ".gen$")
for(j in 1:100) { #(length(list_files))
#creating a temporary genind object (using Adegenet package) for each simulation replicate
temp_genind = read.genepop(list_files[[j]], ncode=3)
#calculating Fst
if(fst_flag == TRUE) {
##creating genind list for QUAC genind
temp_genind_list[[j]] <- temp_genind
##convert genind files to hierfstat format to run pwfst
temp_hierfstat[[j]] <- genind2hierfstat(temp_genind_list[[j]])
##array to store all pwfst values
pwfst <- pairwise.neifst(temp_hierfstat[[j]])
##calculate statistics for QUAC - max, min, mean fst
##and save results in a matrix for all species
mean_max_min_fst[1,j,i] <- mean(pwfst, na.rm = TRUE)
mean_max_min_fst[2,j,i] <- min(pwfst, na.rm = TRUE)
mean_max_min_fst[3,j,i] <- max(pwfst, na.rm = TRUE)
}
#defining the first and last individuals of the entire population, so we know where to sample between
first_ind = 1
last_ind = sum(table(temp_genind@pop))
#for each replicate, sample up to 500 individuals, starting with 1
for(k in 1:max_sample_size) {
#this is a check to make sure that k, the sample size, doesn't exceed the species total pop. size
#the loop will break if k is greater than the total pop. size
#in other words, sampling stops once the entire population has been sampled, or when 500 samples is reached
if(k <= sum(table(temp_genind@pop))) {
#choosing which rows of the matrix to sample from
#rows indicate individuals
rows_to_samp = sample(first_ind:last_ind, k)
#saving the alleles sampled
if(k == 1) {
sample_n_alleles = sum(temp_genind@tab[rows_to_samp,]>0)
} else {
sample_n_alleles = sum(colSums(temp_genind@tab[rows_to_samp,])>0)
}
#calculating the total alleles
total_alleles = ncol(temp_genind@tab)
#saving the proportion of alleles captured -> alleles sampled/total alleles
#represents genetic conservation success
all_quercus_results[k,j,i] = sample_n_alleles/total_alleles
#saving the total alleles present across the populations for each species, and each replicate
total_alleles_all_quercus[k,j,i] = total_alleles
}else {
break
}
}
}
}
#saving results to a .Rdata file
setwd("C:\\Users\\kayle\\Documents\\Quercus_IUCN_samp_sims\\R_scripts")
#save(all_quercus_results, file="all_quercus_results.Rdata")
save(mean_max_min_fst, file="mean_min_max_fst.Rdata")
###################################################################################################
#Fst
load("mean_min_max_fst.Rdata")
mean_max_min_fst
View(mean_max_min_fst)
mean_max_min_fst[,,1] #Q. acerifolia
q_acer_table = (mean_max_min_fst[,,1])
q_acer_table
q_acer_table = table(mean_max_min_fst[,,1])
q_acer_table
mean_max_min_fst[,,1] #Q. acerifolia
q_acer_fst = rowMeans(mean_max_min_fst[,,1])
q_acer_fst
q_engel_fst = rowMeans(mean_max_min_fst[,,6])
q_engel_fst
q_boyn_fst =rowMeans(mean_max_min_fst[,,3])
q_boyn_fst
#######################################################################################################################
#saving results to R data file
setwd("C:\\Users\\kayle\\Documents\\Morton-REU\\samp_pop_sims\\Simulations")
load("lowmig_mean_min_max_fst.Rdata")
load("lowmig_fst_mean_min_max.Rdata")
load("lowMig_fst.Rdata")
